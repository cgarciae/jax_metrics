{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JAX Metrics","text":""},{"location":"#jax-metrics","title":"JAX Metrics","text":"<p>A Metrics library for the JAX ecosystem</p>"},{"location":"#main-features","title":"Main Features","text":"<ul> <li>Standard metrics that can be used in any JAX project.</li> <li>Pytree abstractions that can natively integrate with all JAX APIs and pytree-supporting frameworks (flax.struct, equinox, treex, etc).</li> <li>Distributed-friendly APIs that make it super easy to synchronize metrics across devices.</li> <li>Automatic accumulation over epochs.</li> </ul> <p>JAX Metrics is implemented on top of Treeo.</p>"},{"location":"#what-is-included","title":"What is included?","text":"<ul> <li>The Keras-like <code>Loss</code> and <code>Metric</code> abstractions.</li> <li>A <code>metrics</code> module containing popular metrics.</li> <li>The <code>losses</code> and <code>regularizers</code> modules containing popular losses.</li> <li>The <code>Metrics</code> and <code>Losses</code> combinators.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install using pip: <pre><code>pip install jax_metrics\n</code></pre></p>"},{"location":"#status","title":"Status","text":"<p>Metrics on this library are usually tested against their Keras or Torchmetrics counterparts for numerical equivalence. This code base comes from Treex and Elegy so it's already in use.</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#metric","title":"Metric","text":"<p>The <code>Metric</code> API consists of 3 basic methods:</p> <ul> <li><code>reset</code>: Used to both initialize and reset a metric.</li> <li><code>update</code>: Takes in new data and updates the metric state.</li> <li><code>compute</code>: Returns the current value of the metric.</li> </ul> <p>Simple usage looks like this:</p> <pre><code>import jax_metrics as jm\n\nmetric = jm.metrics.Accuracy()\n\n# Update the metric with a batch of predictions and labels\nmetric = metric.update(target=y, preds=logits)\n\n# Get the current value of the metric\nacc = metric.compute() # 0.95\n\n# alternatively, produce a logs dict\nlogs = metric.compute_logs() # {'accuracy': 0.95}\n\n# Reset the metric\nmetric = metric.reset()\n</code></pre> <p>Note that <code>update</code> enforces the use of keyword arguments. Also the <code>Metric.name</code> property is used as the key in the returned dict, by default this is the name of the class in lowercase but can be overridden in the constructor via the <code>name</code> argument.</p>"},{"location":"#tipical-training-setup","title":"Tipical Training Setup","text":"<p>Because Metrics are pytrees they can be used with <code>jit</code>, <code>pmap</code>, etc. On a more realistic scenario you will proably want to use them inside some of your JAX functions in a setup similar to this:</p> <pre><code>import jax_metrics as jm\n\nmetric = jm.metrics.Accuracy()\n\ndef loss_fn(params, metric, x, y):\n    ...\n    metric = metric.update(target=y, preds=logits)\n    ...\n\n    return loss, metric\n\n@jax.jit\ndef train_step(params, metric, x, y):\n    grads, metric = jax.grad(loss_fn, has_aux=True)(\n        params, metric, x, y\n    )\n    ...\n    return params, metric\n\n@jax.jit\ndef reset_step(metric: jm.Metric) -&gt; jm.Metric:\n    return metric.reset()\n</code></pre> <p>Since the loss function usually has access to the predictions and labels, its usually where you would call <code>metric.update</code>, and the new metric state can be returned as an auxiliary output.</p>"},{"location":"#distributed-training","title":"Distributed Training","text":"<p>JAX Metrics has a distributed friendly API via the <code>batch_updates</code> and <code>reduce</code> methods. A simple example of a loss function inside a data parallel setup could look like this:</p> <pre><code>def loss_fn(params, metric, x, y):\n    ...\n    # compuate batch update\n    batch_updates = metric.batch_updates(target=y, preds=logits)\n    # gather over all devices and reduce\n    batch_updates = jax.lax.all_gather(batch_updates, \"device\").reduce()\n    # update metric\n    metric = metric.merge(batch_updates)\n    ...\n</code></pre> <p>The <code>batch_updates</code> method behaves similar to <code>update</code> but returns a new metric state with only information about that batch, <code>jax.lax.all_gather</code> \"gathers\" the metric state over all devices plus adds a new axis to the metric state, and <code>reduce</code> reduces the metric state over all devices (first axis). Finally, <code>merge</code> combines the accumulated metric state over the previous batches with the batch updates.</p>"},{"location":"#loss","title":"Loss","text":"<p>The <code>Loss</code> API just consists of a <code>__call__</code> method. Simple usage looks like this:</p> <p><pre><code>import jax_metrics as jm\n\ncrossentropy = jm.losses.Crossentropy()\n\n# get reduced loss value\nloss = crossentropy(target=y, preds=logits) # 0.23\n</code></pre> Note that losses are not pytrees so they should be marked as static. Similar to Keras, all losses have a <code>reduction</code> strategy that can be specified in the constructor and (usually) makes sure that the output is a scalar.</p> Why have losses in a metrics library?   There are a few reasons for having losses in a metrics library:  1. Most code from this library was originally written for and will still be consumed by Elegy. Since Elegy needs support for calculating cumulative losses, as you will see later, a Metric abstraction called `Losses` was created for this. 2. A couple of API design decisions are shared between the `Loss` and `Metric` APIs. This includes:      * `__call__` and `update` both accept any number keyword only arguments. This is used to facilitate composition (see [Combinators](#combinators) section).     * Both classes have the `index_into` and `rename_arguments` methods that allow them to modify how arguments are consumed.     * Argument names are standardized to be consistent when ever possible, e.g. both `metrics.Accuracy` and `losses.Crossentropy` use the `target` and `preds` arguments."},{"location":"#combinators","title":"Combinators","text":"<p>Combinators enable you to group together multiple metrics while also being instances of <code>Metric</code> and thus maintaining the same API.</p>"},{"location":"#metrics","title":"Metrics","text":"<p>The <code>Metrics</code> combinator lets you combine multiple metrics into a single Metric object.</p> <pre><code>metrics = jm.Metrics([\n    jm.metrics.Accuracy(),\n    jm.metrics.F1(), # not yet implemented \ud83d\ude05, coming soon?\n])\n\n# same API\nmetrics = metrics.update(target=y, preds=logits)\n# compute now returns a dict\nmetrics.compute() # {'accuracy': 0.95, 'f1': 0.87}\n# same as compute_logs in the case\nmetrics.compute_logs() # {'accuracy': 0.95, 'f1': 0.87}\n# Reset the metrics\nmetrics = metrics.reset()\n</code></pre> <p>As you can see the <code>Metrics.update</code> method accepts and forwards all the arguments required by the individual metrics. In this example they use the same arguments, but in practice they may consume different subsets of the arguments. Also, if names are repeated then unique names are generated for each metric by appending a number to the metric name.</p> <p>If a dictionary is used instead of a list, the keys are used instead of the <code>name</code> property of the metrics to determine the key in the returned dict.</p> <pre><code>metrics = jm.Metrics({\n    \"acc\": jm.metrics.Accuracy(),\n    \"f_one\": jm.metrics.F1(), # not yet implemented \ud83d\ude05, coming soon?\n})\n\n# same API\nmetrics = metrics.update(target=y, preds=logits)\n# compute new returns a dict\nmetrics.compute() # {'acc': 0.95, 'f_one': 0.87}\n# same as compute_logs in the case\nmetrics.compute_logs() # {'acc': 0.95, 'f_one': 0.87}\n# Reset the metrics\nmetrics = metrics.reset()\n</code></pre> <p>You can use nested structures of dicts and lists to group metrics, the keys of the dicts are used to determine group names. Group names and metrics names are concatenated using <code>\"/\"</code> e.g. <code>\"{group_name}/{metric_name}\"</code>.</p>"},{"location":"#losses","title":"Losses","text":"<p><code>Losses</code> is a <code>Metric</code> combinator that behaves very similarly to <code>Metrics</code> but contains <code>Loss</code> instances. <code>Losses</code> calculates the cumulative mean value of each loss over the batches.</p> <pre><code>losses = jm.Losses([\n    jm.losses.Crossentropy(),\n    jm.regularizers.L2(1e-4),\n])\n\n# same API\nlosses = losses.update(target=y, preds=logits, parameters=params)\n# compute new returns a dict\nlosses.compute() # {'crossentropy': 0.23, 'l2': 0.005}\n# same as compute_logs in the case\nlosses.compute_logs() # {'crossentropy': 0.23, 'l2': 0.005}\n# you can also compute the total loss\nloss = losses.total_loss() # 0.235\n# Reset the losses\nlosses = losses.reset()\n</code></pre> <p>As with <code>Metrics</code>, the <code>update</code> method accepts and forwards all the arguments required by the individual losses. In this example <code>target</code> and <code>preds</code> are used by the <code>Crossentropy</code>, while <code>parameters</code> is used by the <code>L2</code>. The <code>total_loss</code> method returns the sum of all values returned by <code>compute</code>.</p> <p>If a dictionary is used instead of a list, the keys are used instead of the <code>name</code> property of the losses to determine the key in the returned dict.</p> <pre><code>losses = jm.Losses({\n    \"xent\": jm.losses.Crossentropy(),\n    \"l2\": jm.regularizers.L2(1e-4),\n})\n\n# same API\nlosses = losses.update(target=y, preds=logits, parameters=params)\n# compute new returns a dict\nlosses.compute() # {'xent': 0.23, 'l2': 0.005}\n# same as compute_logs in the case\nlosses.compute_logs() # {'xent': 0.23, 'l2': 0.005}\n# you can also compute the total loss\nloss = losses.total_loss() # 0.235\n# Reset the losses\nlosses = losses.reset()\n</code></pre> <p>If you want to use <code>Losses</code> to calculate the loss of a model, you should use <code>batch_updates</code> followed by <code>total_loss</code> to get the correct batch loss. For example, a loss function could be written as:</p> <p><pre><code>def loss_fn(..., losses):\n    ...\n    batch_updates = losses.batch_updates(target=y, preds=logits, parameters=params)\n    loss = batch_updates.total_loss()\n    losses = losses.merge(batch_updates)\n    ...\n    return loss, losses\n</code></pre> For convenience, the previous pattern can be simplified to a single line using the <code>loss_and_update</code> method: <pre><code>def loss_fn(...):\n    ...\n    loss, lossses = losses.loss_and_update(target=y, preds=logits, parameters=params)\n    ...\n    return loss, losses\n</code></pre></p>"}]}